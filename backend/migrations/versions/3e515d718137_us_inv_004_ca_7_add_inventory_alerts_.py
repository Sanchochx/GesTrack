"""US-INV-004 CA-7: Add inventory_alerts table and reorder point trigger

Revision ID: 3e515d718137
Revises: 53c4be16db29
Create Date: 2025-11-13 11:05:40.174646

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '3e515d718137'
down_revision = '53c4be16db29'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('inventory_alerts',
    sa.Column('id', sa.String(length=36), nullable=False),
    sa.Column('product_id', sa.String(length=36), nullable=False),
    sa.Column('alert_type', sa.String(length=50), nullable=False),
    sa.Column('current_stock', sa.Integer(), nullable=False),
    sa.Column('reorder_point', sa.Integer(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('resolved_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('inventory_alerts', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_inventory_alerts_alert_type'), ['alert_type'], unique=False)
        batch_op.create_index(batch_op.f('ix_inventory_alerts_is_active'), ['is_active'], unique=False)
        batch_op.create_index(batch_op.f('ix_inventory_alerts_product_id'), ['product_id'], unique=False)

    with op.batch_alter_table('inventory_movements', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('idx_inventory_movements_created'))
        batch_op.drop_index(batch_op.f('idx_inventory_movements_product'))
        batch_op.drop_index(batch_op.f('idx_inventory_movements_product_date'))
        batch_op.drop_index(batch_op.f('idx_inventory_movements_type'))

    # US-INV-004 CA-7: Trigger para alertas de punto de reorden
    # Nota: SQLite triggers son soportados, pero la sintaxis exacta puede variar
    # Este trigger se ejecutará automáticamente cuando el stock sea actualizado
    connection = op.get_bind()

    # Detectar tipo de base de datos
    dialect_name = connection.dialect.name

    if dialect_name == 'sqlite':
        # Trigger para SQLite
        connection.execute(sa.text("""
            CREATE TRIGGER IF NOT EXISTS trigger_reorder_point_alert
            AFTER UPDATE OF stock_quantity ON products
            FOR EACH ROW
            WHEN (NEW.stock_quantity <= NEW.reorder_point AND OLD.stock_quantity > OLD.reorder_point)
            BEGIN
                INSERT INTO inventory_alerts (
                    id, product_id, alert_type, current_stock,
                    reorder_point, is_active, created_at
                )
                SELECT
                    lower(hex(randomblob(4)) || '-' || hex(randomblob(2)) || '-' ||
                          hex(randomblob(2)) || '-' || hex(randomblob(2)) || '-' ||
                          hex(randomblob(6))),
                    NEW.id,
                    'reorder_point',
                    NEW.stock_quantity,
                    NEW.reorder_point,
                    1,
                    datetime('now')
                WHERE NOT EXISTS (
                    SELECT 1 FROM inventory_alerts
                    WHERE product_id = NEW.id
                    AND alert_type = 'reorder_point'
                    AND is_active = 1
                );
            END;
        """))

        # Trigger para resolver alertas cuando el stock sube
        connection.execute(sa.text("""
            CREATE TRIGGER IF NOT EXISTS trigger_resolve_reorder_alert
            AFTER UPDATE OF stock_quantity ON products
            FOR EACH ROW
            WHEN (NEW.stock_quantity > NEW.reorder_point AND OLD.stock_quantity <= OLD.reorder_point)
            BEGIN
                UPDATE inventory_alerts
                SET is_active = 0, resolved_at = datetime('now')
                WHERE product_id = NEW.id
                AND alert_type = 'reorder_point'
                AND is_active = 1;
            END;
        """))

    elif dialect_name == 'postgresql':
        # Trigger para PostgreSQL (para producción)
        connection.execute(sa.text("""
            CREATE OR REPLACE FUNCTION check_reorder_point()
            RETURNS TRIGGER AS $$
            BEGIN
                -- Si el stock baja al punto de reorden o menos
                IF NEW.stock_quantity <= NEW.reorder_point AND OLD.stock_quantity > OLD.reorder_point THEN
                    -- Crear alerta si no existe una activa
                    INSERT INTO inventory_alerts (
                        id, product_id, alert_type, current_stock,
                        reorder_point, is_active, created_at
                    )
                    SELECT
                        gen_random_uuid()::text,
                        NEW.id,
                        'reorder_point',
                        NEW.stock_quantity,
                        NEW.reorder_point,
                        true,
                        NOW()
                    WHERE NOT EXISTS (
                        SELECT 1 FROM inventory_alerts
                        WHERE product_id = NEW.id
                        AND alert_type = 'reorder_point'
                        AND is_active = true
                    );
                END IF;

                -- Si el stock sube por encima del punto de reorden, resolver alertas
                IF NEW.stock_quantity > NEW.reorder_point AND OLD.stock_quantity <= OLD.reorder_point THEN
                    UPDATE inventory_alerts
                    SET is_active = false, resolved_at = NOW()
                    WHERE product_id = NEW.id
                    AND alert_type = 'reorder_point'
                    AND is_active = true;
                END IF;

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER trigger_reorder_point
            AFTER UPDATE OF stock_quantity ON products
            FOR EACH ROW
            EXECUTE FUNCTION check_reorder_point();
        """))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # US-INV-004 CA-7: Eliminar triggers antes de eliminar tabla
    connection = op.get_bind()
    dialect_name = connection.dialect.name

    if dialect_name == 'sqlite':
        connection.execute(sa.text("DROP TRIGGER IF EXISTS trigger_reorder_point_alert"))
        connection.execute(sa.text("DROP TRIGGER IF EXISTS trigger_resolve_reorder_alert"))
    elif dialect_name == 'postgresql':
        connection.execute(sa.text("DROP TRIGGER IF EXISTS trigger_reorder_point ON products"))
        connection.execute(sa.text("DROP FUNCTION IF EXISTS check_reorder_point()"))

    with op.batch_alter_table('inventory_movements', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('idx_inventory_movements_type'), ['movement_type'], unique=False)
        batch_op.create_index(batch_op.f('idx_inventory_movements_product_date'), ['product_id', 'created_at'], unique=False)
        batch_op.create_index(batch_op.f('idx_inventory_movements_product'), ['product_id'], unique=False)
        batch_op.create_index(batch_op.f('idx_inventory_movements_created'), ['created_at'], unique=False)

    with op.batch_alter_table('inventory_alerts', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_inventory_alerts_product_id'))
        batch_op.drop_index(batch_op.f('ix_inventory_alerts_is_active'))
        batch_op.drop_index(batch_op.f('ix_inventory_alerts_alert_type'))

    op.drop_table('inventory_alerts')
    # ### end Alembic commands ###
